# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

""" Zen Checker Texture System """
from json import dumps
import bpy
from ZenUV.zen_checker.zen_checker_labels import ZCheckerLabels as label
from ZenUV.utils.generic import switch_shading_style, resort_by_type_mesh
from ZenUV.zen_checker.files import load_checker_image, update_files_info
from ZenUV.utils.messages import zen_message
from ZenUV.ui.labels import ZuvLabels
from ZenUV.utils.finishing_util import is_finished_activated


ZEN_IMAGE_NODE_NAME = "ZenUV_Texture_node"
ZEN_IMAGE_NAME = "zen-checker@4x.png"
ZEN_GENERATED_IMAGE_NAME = "BlenderChecker"
ZEN_GLOBAL_OVERRIDER_NAME = "Zen UV Checker"
ZEN_GLOBAL_OVERRIDER_NAME_OLD = "ZenUV_Checker"
ZEN_OVERRIDER_NAME = "ZenUV_Override"
ZEN_GENERIC_MAT_NAME = "ZenUV_Generic_Material"
ZEN_NODE_COLOR = (0.701, 0.017, 0.009)


def remove_zen_generic_mats():
    """Remove all Zen Generic Materials from bpy.data"""
    gen_mats = [m for m in bpy.data.materials if ZEN_GENERIC_MAT_NAME in m.name]
    # print("Generic Mats:", gen_mats)
    for mat in gen_mats:
        bpy.data.materials.remove(mat)


def zen_generic_mat():
    """ Return a Zen UV Generic material or create one and return """
    generic_material = bpy.data.materials.get(ZEN_GENERIC_MAT_NAME, None)
    if not generic_material:
        generic_material = bpy.data.materials.new(name=ZEN_GENERIC_MAT_NAME)
        generic_material.use_nodes = True
        generic_material.use_fake_user = True
    return generic_material


def zen_checker_image(context):
    """ Return Zen UV Checker image or create one and Return """
    addon_prefs = context.preferences.addons[ZuvLabels.ADDON_NAME].preferences
    image = load_checker_image(context, addon_prefs.ZenCheckerImages)
    if not image:
        bpy.ops.image.new(
            name=ZEN_GENERATED_IMAGE_NAME,
            width=1024,
            height=1024,
            alpha=False,
            generated_type='UV_GRID',
            float=False,
            use_stereo_3d=False)
        image = bpy.data.images.get(ZEN_GENERATED_IMAGE_NAME)
        zen_message(context, message="The current Checker texture is not properly defined. The checker texture generated by Blender is used.", title="Zen Checker")

    return image


def zen_checker_image_update(context, _image):
    interpolation = {True: 'Linear', False: 'Closest'}
    _overrider = None
    if bpy.data.node_groups.items():
        _overrider = bpy.data.node_groups.get(ZEN_GLOBAL_OVERRIDER_NAME, None)
    if _overrider:
        if hasattr(_overrider, "nodes"):
            image_node = _overrider.nodes.get(ZEN_IMAGE_NODE_NAME)
            if image_node:
                image_node.image = _image
                image_node.interpolation = interpolation[context.scene.zen_uv.tex_checker_interpolation]


def zen_checker_image_enshure(context):
    """
    Enshure Checker (any) image exist in ZEN IMAGE NODE.
    """
    addon_prefs = context.preferences.addons[ZuvLabels.ADDON_NAME].preferences
    _overrider = None
    if bpy.data.node_groups.items():
        _overrider = bpy.data.node_groups.get(ZEN_GLOBAL_OVERRIDER_NAME, None)
    if _overrider:
        if hasattr(_overrider, "nodes"):
            image_node = _overrider.nodes.get(ZEN_IMAGE_NODE_NAME)
            if image_node:
                if not image_node.image:
                    bpy.ops.wm.call_menu(name="ZUV_MT_ZenChecker_Popup")
                else:
                    image_node.image = load_checker_image(context, addon_prefs.ZenCheckerImages)


def enshure_material_slots(context, _obj):
    """ Return material slots or create single material slot if empty """
    return _obj.material_slots or create_material_slot(context, _obj)


def create_material_slot(context, _obj):
    """ Create Material Slot and Zen Generic material inside slot. Return new slot """
    context.view_layer.objects.active = _obj
    bpy.ops.object.material_slot_add()

    return _obj.material_slots


def enshure_material(_slot):
    """ If slot material is empty - insert in given slot
    Zen UV Generic material and switch to tree mode """
    if not _slot.material:
        _slot.material = zen_generic_mat().copy()


def enshure_user_mats_consistency(context, _objs):
    """ Refine and repair user materials from selected objects """
    for _obj in _objs:
        for _slot in enshure_material_slots(context, _obj):
            enshure_material(_slot)


def get_materials_from_objects(context, objs):
    """ Return materials from given objects set """
    _materials = []
    for _obj in objs:
        for _slot in enshure_material_slots(context, _obj):
            _materials.append(_slot.material)
    return _materials


def create_zen_global_overrider_node_tree(context, _overrider, create_in_out=True):
    """ Create node tree for Zen UV Global Overrider """
    # Create group inputs
    group_inputs = _overrider.nodes.new('NodeGroupInput')
    group_inputs.location = (-200, 0)

    # Create group outputs
    group_outputs = _overrider.nodes.new('NodeGroupOutput')
    group_outputs.location = (400, 0)

    if create_in_out:
        _overrider.inputs.new('NodeSocketShader', 'MainShader')
        _overrider.outputs.new('NodeSocketShader', 'MixedShader')

    # Create image node
    image_node = _overrider.nodes.new(type='ShaderNodeTexImage')
    image_node.name = ZEN_IMAGE_NODE_NAME
    image_node.image = zen_checker_image(context)

    # Link outputs
    _overrider.links.new(image_node.outputs[0], group_outputs.inputs['MixedShader'])


def Zen_Global_Overrider(context):
    """ Create and return Zen UV Global Overrider """
    # Create a global overrider node group
    global_overrider = bpy.data.node_groups.new(ZEN_GLOBAL_OVERRIDER_NAME, 'ShaderNodeTree')
    create_zen_global_overrider_node_tree(context, global_overrider)
    global_overrider.use_fake_user = True
    return global_overrider


def disable_overrider(context, _materials):
    """ Disable overrider """
    for _material in _materials:
        node_before_overrider = None
        node_after_overrider = None
        overriders = get_overrider(_material)
        for overrider in overriders:
            if hasattr(overrider, "inputs"):
                if overrider.inputs[0].links:
                    node_before_overrider = overrider.inputs[0].links[0].from_node
            if hasattr(overrider, "outputs"):
                if overrider.outputs[0].links:
                    node_after_overrider = overrider.outputs[0].links[0].to_node
            _links = _material.node_tree.links
            # Remove link from Overrider node to User output material node
            if node_before_overrider:
                # print("NODE BEFORE OVERRIDER: ", node_before_overrider)
                _links.remove(node_before_overrider.outputs[0].links[0])
            # Create link from shader (prev node) to User output material node
            if node_before_overrider and node_after_overrider:
                _links.new(node_before_overrider.outputs[0], node_after_overrider.inputs[0])
            # print("Overrider", overrider, " disabled in: ", _material.name)
            if overrider:
                _material.node_tree.nodes.remove(overrider)
                if node_after_overrider:
                    node_after_overrider.socket_value_update(context)


def get_materials_with_overrider(_materials):
    """ Returm all the materials contained overrider from given set of the materials """
    _materials_with_overrider = []
    for material in _materials:
        if hasattr(material, "node_tree"):
            if hasattr(material.node_tree, "nodes"):
                for node in material.node_tree.nodes:
                    if hasattr(node, "node_tree"):
                        if node.node_tree.name == ZEN_GLOBAL_OVERRIDER_NAME \
                                or node.node_tree.name == ZEN_GLOBAL_OVERRIDER_NAME_OLD:
                            _materials_with_overrider.append(material)
    return _materials_with_overrider


def get_overrider(_material):
    """ Return overriders from given material """
    overriders = []
    if hasattr(_material, "node_tree"):
        if hasattr(_material.node_tree, "nodes"):
            for _node in _material.node_tree.nodes:
                if hasattr(_node, "node_tree"):
                    if _node.node_tree.name == ZEN_GLOBAL_OVERRIDER_NAME \
                            or _node.node_tree.name == ZEN_GLOBAL_OVERRIDER_NAME_OLD:
                        overriders.append(_node)
    return overriders


def implement_zen_overrider(context, _obj, _GlobalOverrider):
    """ Zen Overrider Implementation """
    # Check material slots. If NOT - Create one and standart material.
    material_slots = enshure_material_slots(context, _obj)

    for slot in material_slots:
        enshure_material(slot)
        mat_nodes = slot.material.node_tree.nodes

        # Check if Zen Overrider exist in Current material nodes
        zen_checker = mat_nodes.get(ZEN_OVERRIDER_NAME)
        if not zen_checker:
            zen_checker = mat_nodes.new(type="ShaderNodeGroup")
            zen_checker.node_tree = _GlobalOverrider
            zen_checker.name = ZEN_OVERRIDER_NAME
            zen_checker.location = (200, 200)
        mat_nodes.active = zen_checker
        zen_checker.use_custom_color = True
        zen_checker.color = ZEN_NODE_COLOR

        # Implement Zen Overraider in to user material
        links = slot.material.node_tree.links

        # Define Material Output Node
        user_material_output_nodes = [node for node in mat_nodes if node.bl_rna.name == "Material Output"]
        if not user_material_output_nodes:
            mat_nodes.new("ShaderNodeOutputMaterial")
            user_material_output_nodes = [node for node in mat_nodes if node.bl_rna.name == "Material Output"]
        # user_material_output_node = user_material_output_nodes[0]
        user_mat_out_node_inputs = user_material_output_nodes[0].inputs
        out_location = user_material_output_nodes[0].location
        zen_checker.location = (out_location.x - 200, out_location.y)

        # Define Zen Overrider Input and Output Channels
        zen_overrider_outputs = mat_nodes.get(ZEN_OVERRIDER_NAME).outputs
        zen_overrider_inputs = mat_nodes.get(ZEN_OVERRIDER_NAME).inputs

        prev_user_link = None
        if user_mat_out_node_inputs["Surface"].links:
            prev_user_link = user_mat_out_node_inputs["Surface"].links[0].from_node

        if prev_user_link and prev_user_link.name != ZEN_OVERRIDER_NAME:

            links.new(zen_overrider_outputs[0], user_mat_out_node_inputs[0])
            prev_user_link = links.new(zen_overrider_inputs[0], prev_user_link.outputs[0])
        else:
            links.new(zen_overrider_outputs[0], user_mat_out_node_inputs[0])


def repair_zen_generic_mat():
    """ Repair Zen UV Generic material """
    mat = zen_generic_mat()
    # mat.use_nodes = True
    _links = mat.node_tree.links
    pr_bsdf_node = mat.node_tree.nodes.get("Principled BSDF")
    # print("NODE BSDF", pr_bsdf_node)
    if not pr_bsdf_node:
        pr_bsdf_node = mat.node_tree.nodes.new(type="ShaderNodeBsdfPrincipled")
    pr_bsdf_node_output = pr_bsdf_node.outputs[0]

    mat_output = mat.node_tree.nodes.get("Material Output")
    # print("NODE OUTPUT", pr_bsdf_node)
    if not mat_output:
        mat_output = mat.node_tree.nodes.new(type="ShaderNodeBsdfPrincipled")
    mat_output_input = mat_output.inputs[0]

    _links.new(pr_bsdf_node_output, mat_output_input)


def repair_zen_overrider(context):
    """ Repair Zen UV Global overrider to default state or create new if no exist in data blocks """
    # print("Zen UV: Reset Checker")
    _overrider = None
    if bpy.data.node_groups.items():
        _overrider = bpy.data.node_groups.get(ZEN_GLOBAL_OVERRIDER_NAME, None)
    if _overrider:
        # print("Zen UV Global overrider repairing.")
        _overrider.nodes.clear()
        create_zen_global_overrider_node_tree(context, _overrider, create_in_out=False)
    else:
        _overrider = Zen_Global_Overrider(context)


def remove_zen_overrider(context):
    """ Remove Zen UV Overrider from all Materials in scene """
    disable_overrider(context, bpy.data.materials)


def disable_checker_in_uv_layout(context):
    screen = context.screen
    for area in screen.areas:
        if area.type == 'IMAGE_EDITOR':
            area.spaces.active.image = None


class ZUVChecker_OT_CheckerToggle(bpy.types.Operator):
    """ Zen UV Checker Processor """
    bl_idname = "view3d.zenuv_checker_toggle"
    bl_label = label.OT_CHECKER_TOGGLE_LABEL
    bl_description = label.OT_CHECKER_TOGGLE_DESC
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.selected_objects

    def execute(self, context):
        sel_objects = resort_by_type_mesh(context)
        for obj in sel_objects:
            if len(obj.data.uv_layers) == 0:
                obj.data.uv_layers.new()
            obj.material_slots.update()
            obj.update_from_editmode()

        # Get or create Global Overrider
        GlobalOverrider = bpy.data.node_groups.get(ZEN_GLOBAL_OVERRIDER_NAME) or Zen_Global_Overrider(context)
        enshure_user_mats_consistency(context, sel_objects)
        # addon_prefs = context.preferences.addons[ZuvLabels.ADDON_NAME].preferences
        materials_with_overrider = get_materials_with_overrider(get_materials_from_objects(context, sel_objects))
        finished_vc_map = is_finished_activated(context)
        # if finished_vc_map and materials_with_overrider:
        #     style = current_shading_style(context)
        #     if style == "TEXTURE":
        #         style = "VERTEX"
        #     elif style == "VERTEX":
        #         style = "TEXTURE"
        #     switch_shading_style(context, style, switch=False)
        if materials_with_overrider:  # Case checker exist in currently selected objects - Turn Off Checker
            disable_overrider(context, materials_with_overrider)
            finished_vc_map = is_finished_activated(context)
            if finished_vc_map:
                # bpy.ops.object.mode_set(mode='VERTEX_PAINT')
                # bpy.ops.object.mode_set(mode="EDIT")
                switch_shading_style(context, "VERTEX", switch=False)
            # update_image_in_uv_layout(context, None)
            # fit_uv_view(context, mode="all")
        else:  # Else - Turn On Checker
            repair_zen_generic_mat()
            for obj in sel_objects:
                implement_zen_overrider(context, obj, GlobalOverrider)
            # update_image_in_uv_layout(context, bpy.data.images.get(addon_prefs.ZenCheckerImages))
            zen_checker_image_enshure(context)
            # fit_uv_view(context, mode="checker")
            switch_shading_style(context, "TEXTURE", switch=False)

        return {'FINISHED'}


class ZUVChecker_OT_Reset(bpy.types.Operator):
    """ Zen UV Checker Reset """
    bl_idname = "view3d.zenuv_checker_reset"
    bl_label = label.OT_CHECKER_RESET_LABEL
    bl_description = label.OT_CHECKER_RESET_DESC
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        addon_prefs = context.preferences.addons[ZuvLabels.ADDON_NAME].preferences
        addon_prefs.rez_filter = False
        repair_zen_overrider(context)
        return {'FINISHED'}


class ZUVChecker_OT_Remove(bpy.types.Operator):
    """ Zen UV Checker Remove """
    bl_idname = "view3d.zenuv_checker_remove"
    bl_label = label.OT_CHECKER_REMOVE_LABEL
    bl_description = label.OT_CHECKER_REMOVE_DESC
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        remove_zen_overrider(context)
        disable_checker_in_uv_layout(context)
        remove_zen_generic_mats()
        return {'FINISHED'}


class ZUVChecker_OT_OpenEditor(bpy.types.Operator):
    """ Zen UV Checker Remove """
    bl_idname = "view3d.zenuv_checker_open_editor"
    bl_label = label.OT_CHECKER_OPEN_EDITOR_LABEL
    bl_description = label.OT_CHECKER_OPEN_EDITOR_DESC
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        if context.selected_objects:
            return True

    def execute(self, context):
        try:
            obj = context.selected_objects[0]
            material = obj.material_slots[0].material
            # bpy.context.preferences.active_section = 'VIEWPORT'
            bpy.ops.screen.userpref_show("INVOKE_DEFAULT")
            area = context.window_manager.windows[-1].screen.areas[0]
            area.type = 'NODE_EDITOR'
            # Seems like in 2.9 have some changes in API next line is for
            area.ui_type = 'ShaderNodeTree'

            area.spaces.active.node_tree = material.node_tree
            overrider = material.node_tree.nodes[ZEN_OVERRIDER_NAME]
            # node_group.select = True
            area.spaces.active.node_tree.nodes.active = overrider
            bpy.ops.node.group_edit()
        except Exception:
            print("Seems like problem with Shader editor opening...")

        return {'FINISHED'}


class ZUVChecker_OT_ResetPath(bpy.types.Operator):
    bl_idname = "ops.zenuv_checker_reset_path"
    bl_label = label.OT_RESET_PATH_LABEL
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = label.OT_RESET_PATH_DESC

    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        layout = self.layout
        layout.label(text=label.MESS_RESET_PATH)
        layout.separator()

    def execute(self, context):
        addon_prefs = context.preferences.addons[ZuvLabels.ADDON_NAME].preferences
        items = addon_prefs.__annotations__.keys()
        for pref in items:
            if pref == "assetspath":
                addon_prefs.property_unset(pref)
        # Update main dict
        addon_prefs.files_dict = dumps(update_files_info(addon_prefs.assetspath))
        addon_prefs["SizesY"] = 0
        addon_prefs["ZenCheckerImages"] = 0
        return {'FINISHED'}


if __name__ == '__main__':
    pass
